/**
 * PoWorth Anchor Client
 *
 * Wraps the Anchor program for easy interaction with WorthHub on-chain program.
 */

import * as anchor from "@coral-xyz/anchor";
import {
  Connection,
  Keypair,
  PublicKey,
  SystemProgram,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";
import jsSha3 from "js-sha3";
const { keccak_256 } = jsSha3;
import { TopicInfo, CommitmentInfo, TopicStatus } from "./protocol";

// IDL will be generated by `anchor build` â€” we use a type-safe approach
// For now, we define the program ID and use dynamic IDL loading

export const PROGRAM_ID = new PublicKey(
  "8qXNZGRTwYeAw3fdPsaqJ3cq5ieyZWtxrXTZizmuZFeQ"
);

/**
 * Derive the PDA for a topic account
 */
export function findTopicPDA(topicId: number): [PublicKey, number] {
  const buf = Buffer.alloc(8);
  buf.writeBigUInt64LE(BigInt(topicId));
  return PublicKey.findProgramAddressSync(
    [Buffer.from("topic"), buf],
    PROGRAM_ID
  );
}

/**
 * Derive the PDA for a vault account
 */
export function findVaultPDA(topicPubkey: PublicKey): [PublicKey, number] {
  return PublicKey.findProgramAddressSync(
    [Buffer.from("vault"), topicPubkey.toBuffer()],
    PROGRAM_ID
  );
}

/**
 * Derive the PDA for a commitment account
 */
export function findCommitmentPDA(
  topicPubkey: PublicKey,
  participant: PublicKey
): [PublicKey, number] {
  return PublicKey.findProgramAddressSync(
    [
      Buffer.from("commitment"),
      topicPubkey.toBuffer(),
      participant.toBuffer(),
    ],
    PROGRAM_ID
  );
}

/**
 * Compute the commitment hash: keccak256(prediction_value || salt || participant_address)
 */
export function computeCommitmentHash(
  predictionValue: number,
  salt: Buffer,
  participant: PublicKey
): Buffer {
  const buf = Buffer.alloc(8 + 32 + 32);
  buf.writeBigInt64LE(BigInt(predictionValue), 0);
  salt.copy(buf, 8);
  participant.toBuffer().copy(buf, 40);
  const hash = keccak_256.arrayBuffer(buf);
  return Buffer.from(hash);
}

/**
 * Generate a random 32-byte salt
 */
export function generateSalt(): Buffer {
  return Buffer.from(Keypair.generate().secretKey.slice(0, 32));
}

/**
 * High-level client for interacting with the WorthHub program
 */
export class WorthHubClient {
  public program: anchor.Program;
  public connection: Connection;

  constructor(
    program: anchor.Program,
    connection: Connection,
  ) {
    this.program = program;
    this.connection = connection;
  }

  /**
   * Create a new prediction topic
   */
  async createTopic(
    authority: Keypair,
    oracleAuthority: PublicKey,
    topicId: number,
    description: string,
    symbol: string,
    commitDeadline: number,
    revealDeadline: number,
    minStake: number
  ): Promise<string> {
    const [topicPDA] = findTopicPDA(topicId);
    const [vaultPDA] = findVaultPDA(topicPDA);

    const tx = await this.program.methods
      .createTopic(
        new anchor.BN(topicId),
        description,
        symbol,
        new anchor.BN(commitDeadline),
        new anchor.BN(revealDeadline),
        new anchor.BN(minStake)
      )
      .accounts({
        authority: authority.publicKey,
        oracleAuthority: oracleAuthority,
        topic: topicPDA,
        vault: vaultPDA,
        systemProgram: SystemProgram.programId,
      })
      .signers([authority])
      .rpc();

    return tx;
  }

  /**
   * Submit a commitment
   */
  async commit(
    participant: Keypair,
    topicId: number,
    commitmentHash: Buffer,
    stakeAmount: number
  ): Promise<string> {
    const [topicPDA] = findTopicPDA(topicId);
    const [vaultPDA] = findVaultPDA(topicPDA);
    const [commitmentPDA] = findCommitmentPDA(
      topicPDA,
      participant.publicKey
    );

    const tx = await this.program.methods
      .commit(
        Array.from(commitmentHash) as number[],
        new anchor.BN(stakeAmount)
      )
      .accounts({
        participant: participant.publicKey,
        topic: topicPDA,
        commitment: commitmentPDA,
        vault: vaultPDA,
        systemProgram: SystemProgram.programId,
      })
      .signers([participant])
      .rpc();

    return tx;
  }

  /**
   * Reveal a commitment
   */
  async reveal(
    participant: Keypair,
    topicId: number,
    predictionValue: number,
    salt: Buffer
  ): Promise<string> {
    const [topicPDA] = findTopicPDA(topicId);
    const [commitmentPDA] = findCommitmentPDA(
      topicPDA,
      participant.publicKey
    );

    const tx = await this.program.methods
      .reveal(
        new anchor.BN(predictionValue),
        Array.from(salt) as number[]
      )
      .accounts({
        participant: participant.publicKey,
        topic: topicPDA,
        commitment: commitmentPDA,
      })
      .signers([participant])
      .rpc();

    return tx;
  }

  /**
   * Oracle finalizes the topic with the true value
   */
  async finalize(
    oracle: Keypair,
    topicId: number,
    truthValue: number
  ): Promise<string> {
    const [topicPDA] = findTopicPDA(topicId);

    const tx = await this.program.methods
      .finalize(new anchor.BN(truthValue))
      .accounts({
        oracleAuthority: oracle.publicKey,
        topic: topicPDA,
      })
      .signers([oracle])
      .rpc();

    return tx;
  }

  /**
   * Settle the topic and distribute rewards
   *
   * @param commitmentParticipantPairs - Array of [commitmentPDA, participantPubkey]
   */
  async settle(
    authority: Keypair,
    topicId: number,
    commitmentParticipantPairs: [PublicKey, PublicKey][]
  ): Promise<string> {
    const [topicPDA] = findTopicPDA(topicId);
    const [vaultPDA] = findVaultPDA(topicPDA);

    // Build remaining accounts: [commitment, participant, commitment, participant, ...]
    const remainingAccounts: anchor.web3.AccountMeta[] = [];
    for (const [commitmentPDA, participant] of commitmentParticipantPairs) {
      remainingAccounts.push({
        pubkey: commitmentPDA,
        isSigner: false,
        isWritable: true,
      });
      remainingAccounts.push({
        pubkey: participant,
        isSigner: false,
        isWritable: true,
      });
    }

    const tx = await this.program.methods
      .settle()
      .accounts({
        authority: authority.publicKey,
        topic: topicPDA,
        vault: vaultPDA,
        systemProgram: SystemProgram.programId,
      })
      .remainingAccounts(remainingAccounts)
      .signers([authority])
      .rpc();

    return tx;
  }

  /**
   * Fetch a topic's on-chain data
   */
  async fetchTopic(topicId: number): Promise<TopicInfo | null> {
    const [topicPDA] = findTopicPDA(topicId);
    try {
      const account = await this.program.account.topic.fetch(topicPDA);
      return {
        topic_id: (account.topicId as anchor.BN).toNumber(),
        authority: (account.authority as PublicKey).toBase58(),
        oracle_authority: (account.oracleAuthority as PublicKey).toBase58(),
        description: account.description as string,
        symbol: account.symbol as string,
        commit_deadline: (account.commitDeadline as anchor.BN).toNumber(),
        reveal_deadline: (account.revealDeadline as anchor.BN).toNumber(),
        status: this.mapStatus(account.status),
        truth_value: (account.truthValue as anchor.BN).toNumber(),
        total_stake: (account.totalStake as anchor.BN).toNumber(),
        commitment_count: account.commitmentCount as number,
        reveal_count: account.revealCount as number,
        min_stake: (account.minStake as anchor.BN).toNumber(),
      };
    } catch {
      return null;
    }
  }

  /**
   * Fetch a commitment's on-chain data
   */
  async fetchCommitment(
    topicId: number,
    participant: PublicKey
  ): Promise<CommitmentInfo | null> {
    const [topicPDA] = findTopicPDA(topicId);
    const [commitmentPDA] = findCommitmentPDA(topicPDA, participant);
    try {
      const account = await this.program.account.commitment.fetch(commitmentPDA);
      return {
        topic: (account.topic as PublicKey).toBase58(),
        participant: (account.participant as PublicKey).toBase58(),
        commitment_hash: Buffer.from(account.commitmentHash as number[]).toString("hex"),
        stake_amount: (account.stakeAmount as anchor.BN).toNumber(),
        submit_order: account.submitOrder as number,
        prediction_value: (account.predictionValue as anchor.BN).toNumber(),
        revealed: account.revealed as boolean,
        settled: account.settled as boolean,
      };
    } catch {
      return null;
    }
  }

  /**
   * Fetch all topics (using getProgramAccounts)
   */
  async fetchAllTopics(): Promise<TopicInfo[]> {
    const accounts = await this.program.account.topic.all();
    return accounts.map((a) => ({
      topic_id: (a.account.topicId as anchor.BN).toNumber(),
      authority: (a.account.authority as PublicKey).toBase58(),
      oracle_authority: (a.account.oracleAuthority as PublicKey).toBase58(),
      description: a.account.description as string,
      symbol: a.account.symbol as string,
      commit_deadline: (a.account.commitDeadline as anchor.BN).toNumber(),
      reveal_deadline: (a.account.revealDeadline as anchor.BN).toNumber(),
      status: this.mapStatus(a.account.status),
      truth_value: (a.account.truthValue as anchor.BN).toNumber(),
      total_stake: (a.account.totalStake as anchor.BN).toNumber(),
      commitment_count: a.account.commitmentCount as number,
      reveal_count: a.account.revealCount as number,
      min_stake: (a.account.minStake as anchor.BN).toNumber(),
    }));
  }

  private mapStatus(status: any): TopicStatus {
    if (status.open) return TopicStatus.Open;
    if (status.revealing) return TopicStatus.Revealing;
    if (status.finalized) return TopicStatus.Finalized;
    if (status.settled) return TopicStatus.Settled;
    return TopicStatus.Open;
  }
}
